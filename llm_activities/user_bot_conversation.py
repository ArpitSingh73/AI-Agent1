import google.generativeai as genai
import json
import os
from dotenv import load_dotenv
# from voice_processing.text_to_speech import convert_text_to_speech
load_dotenv(".env")


def extract_date_time(chat_history: list, date_and_time: str, upcoming_events):

    try:
        print("Luna: Processing your query .... give me a moment please.")
        # gemini_prompt = os.environ.load("GEMINI_PROMPT")
        # return {"response" : {"greeting":"good morning sunshine"}}
        genai.configure(api_key=os.environ.get("GEMINI_API_KEY"))
        model = genai.GenerativeModel(
            model_name=os.environ.get("GEMINI_MODEL"),
            system_instruction=f"""You are an Advanced AI agent capable of understaning the user intent from users chat. Your name is Luna.\
            Based on the data you need to extract the date and time user wants to schedule a meeting.\
            Based on the chat history, four cases may arise -

            ##CASE 1 - If user inputs greeting then follow the given instructions strictly.\
            <FOR CASE 1>
            Response then in a polite human conversation manner and greet them accordingly also promote them to share date and time information to book the call.\
            Response in JSON format with key named as - greeting and use the value of the greeting response generated by you.\
            </FOR CASE 1>

            ##CASE 2 - You are able to get date, start time and end time using chat history to schedule a call then follow the given instructions strictly. Make sure it does not overlaps with already booked events.\
            <FOR CASE 2>
            simply return answer in JSON format with three keys - date, start_time and end_time in utc format same as present date and time, check sample here: {date_and_time}
            </FOR CASE 2>

            ##CASE 3 More details are required then follow the given instructions strictly.\
            <FOR CASE 3>
            Ask user politely in human conversation manner to share date and time information to book the call. Return answer in JSON format with one key named as insufficient_context and its value as the asnwer you generated.\
            </FOR CASE 3>

            ##CASE 4 - User requires you to fiind the available slots to book the call.\
            <FOR CASE 4>
            Then check in the details of booked event passed and find out if slot is empty or not and responsd accordingly. Return answer in JSON format with one key named as insufficient_context and its value as the asnwer you generated.\
            </FOR CASE 4>

            ##CASE 5 - query is completely irrelevant and does not belongs to booking a ticket then follow the given instructions strictly.
            <FOR CASE 5>
            These type are queries are not meant to answer just return answe in JSON format with key named as - invalied_query and value as - invalid_query\
            </FOR CASE 5>

            do not use json word in response.\
            Use their name if present in cohat history to make chats more naural.\
            The user chat history is: {chat_history}
            present date and time: {date_and_time}
            Here are the list of booked and upcoming events: {upcoming_events}   """,
            generation_config={"response_mime_type": "application/json"},
        )
        response = model.generate_content(chat_history)
        response = json.loads(response.text)

        return {"success": True, "response": response}
    except Exception as e:
        print(f"Error generating response: {e}")
        return {
            "success": False,
            "response": {
                "llm_failure": "Sorry, I couldn't generate a response at this time."
            },
        }
