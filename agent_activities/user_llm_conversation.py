"""
module containing all the Agentic logic like understanding the user intent and take action accordingly.
"""

import google.generativeai as genai
import json
import os
from dotenv import load_dotenv
load_dotenv(".env")


def extract_date_time(chat_history: list, date_and_time: str, upcoming_events):

    try:

        if len(upcoming_events) == 0:
            upcoming_events.append("No events are scheduled for the specified time range.")

        print("Luna: Processing your query .... give me a moment please.")
        # gemini_prompt = os.environ.load("GEMINI_PROMPT")
        genai.configure(api_key=os.environ.get("GEMINI_API_KEY"))
        model = genai.GenerativeModel(
            model_name=os.environ.get("GEMINI_MODEL"),
            # system_instruction=f"""{gemini_prompt}""",
            system_instruction=f"""You are an Advanced AI agent capable of understaning the user intent from chat history. Your name is Luna.\
            Based on the data passed you need to extract the date and time user wants to schedule a meeting.\
            
            The user chat history is: {chat_history}
            Details of booked events: {upcoming_events}
            
            Based on the chat history, five cases may arise -

            ##CASE 1 - If user inputs greeting then follow the given instructions strictly.\
            <FOR CASE 1>
            Response the user in a polite human conversation manner and greet them accordingly also promote them to share date and time information to book the call.\
            Response in JSON format with key named as - greeting and use the value of the greeting response generated by you.\
            </FOR CASE 1>

            ##CASE 2 - You are able to get date, start time and end time using chat history to schedule a call then follow the given instructions strictly.\
            <FOR CASE 2>
            simply return answer in JSON format with three keys - date, start_time and end_time in utc format same as present date and time, check sample here: {date_and_time}
            </FOR CASE 2>

            ##CASE 3 More details are required then follow the given instructions strictly.\
            <FOR CASE 3>
            Ask user politely in human conversation manner to share date or time information whichever is missing in chat history to book the call. Return answer in JSON format with one key named as insufficient_context and its value as the asnwer you generated.\
            </FOR CASE 3>

            ##CASE 4 - User wants to know if there are booked call on a day, a time period etc.\
            <FOR CASE 4>
            User may ask for whole day, a specified interval or may be in few hours, you need to analyze properly the booked events array here: {upcoming_events} \
            Empty list of upcoming events means no events / call is scheduled, inform user saying something like - there is no call scheduled for the specified time.\
            In this case you only have to return the details of occupied slots with date and time of slots, if any.\
            Inform about date and time of all the slots booked.\
            Return answer in JSON format with one key named as insufficient_context and its value as the asnwer you generated.\
            </FOR CASE 4>

            ##CASE 5 - query is completely irrelevant and does not belongs to booking a ticket then follow the given instructions strictly.
            <FOR CASE 5>
            These type are queries are not meant to answer just return answe in JSON format with key named as - invalid_query and value as - invalid_query\
            </FOR CASE 5>

            do not use json word in response.\
            if not mentioned by user then consider all the date to be of present month only, use: {date_and_time}\
            Use their name if present in chat history to make chats more naural.\
            Use the present date and time passed to know about present time and date.\
            """,
            generation_config={"response_mime_type": "application/json"},
        )
        response = model.generate_content(chat_history)
        response = json.loads(response.text)
 
        return {"success": True, "response": response}
    except Exception as e:
        print(f"Error generating response: {e}")
        return {
            "success": False,
            "response": {
                "llm_failure": "Sorry, I couldn't generate a response at this time."
            },
        }
